using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct PVR_DBRec
{
    // Event & Showtime Info
    public uint pvr_id;         // Unique PVR_ID (based on counter)
    public uint programID;     // System-wide unique identifier for this programID

    // SM - 20060927 - Adding some new fields for Mercury
    public uint ui32SeriesID;  // Mercury Series ID
    public long quideStartSeconds; // Starting time in seconds since 1970 - copied from IPG
    public long scheduleTime;    // Time recording was scheduled

    [StructLayout(LayoutKind.Explicit)]
    public struct PVR_DataUnion
    {
        [FieldOffset(0)]
        public PVR_InstanceData instanceData;
        [FieldOffset(0)]
        public PVR_SeriesData seriesData;
        [FieldOffset(0)]
        public PVR_SyncNGoData syncData;
    }
    public PVR_DataUnion pvrData;

    public ushort dataLen;          // Length of VarData
    public ushort title;            // Name of the program. (offset into vardata).
    public ushort shortDescription; // Plot summary, etc. (offset into vardata).
    public ushort filenameRoot;     // Filename Root (offset into vardata).
    public ushort moreInfo;         // offset into vardata.
    public ushort serviceID;        // BBA servicelD representing channel that the event is on.
    public ushort dispChannel;      // DispChannel - Jim Added
    public ushort quideRunningTime; // 1..65535. in minutes - copied from IPG data
    public ushort qualifiers;       // KshowTimeQual_ClosedCaptioned, etc.
    public ushort callLetters;      // Service Call Letters aka shortName (offset into vardata).
    public ushort pvrFlags;         // Changed from ui8
    public byte category;           // Category/gene of the program.
    public byte eventFlags;         // kEventInfoFlags_NewRelease, etc.
    public byte showtimeFlags1;     // flags. eg KshowtimeFlag1_IspPVEvent

#if LITTLE_ENDIAN_PLATFORM // You'll need to define this preprocessor directive if your target platform is little-endian
    [FieldOffset(46)] // Adjust offset based on struct packing
    public byte mpaaSvldRating;
    public byte mpaaRating
    {
        get { return (byte)(mpaaSvldRating & 0x0F); }
        set { mpaaSvldRating = (byte)((mpaaSvldRating & 0xF0) | (value & 0x0F)); }
    }
    public byte svldRating
    {
        get { return (byte)((mpaaSvldRating >> 4) & 0x0F); }
        set { mpaaSvldRating = (byte)((value << 4) | (mpaaSvldRating & 0x0F)); }
    }
#else
    [FieldOffset(46)] // Adjust offset based on struct packing
    public byte svldMpaaRating;
    public byte svldRating
    {
        get { return (byte)((svldMpaaRating >> 4) & 0x0F); }
        set { svldMpaaRating = (byte)((value << 4) | (svldMpaaRating & 0x0F)); }
    }
    public byte mpaaRating
    {
        get { return (byte)(svldMpaaRating & 0x0F); }
        set { svldMpaaRating = (byte)((svldMpaaRating & 0xF0) | (value & 0x0F)); }
    }
#endif

    public byte contentAdvisory;    // kContentMildviolence, kContentAdultlang, etc.
    public byte pvrRecordType;      // Record Type
    public byte earlyMinutes;       // Minutes to start early (preferred, but not guaranteed)
    public byte lateMinutes;        // Minutes to end late (preferred, but not guaranteed)
    public byte recordQuality;      // Currently unused

    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] // Assuming MAX_CLIENTID_LEN is 32
    public string ClientID;

    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)] // Assuming MAX_CLIENTID_LEN is 32
    public string eventClientId; // Client ID of the box which initiated the user's request.

    public uint unusedS;
    public uint unused6;

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
    public byte[] vardata;         // Pointer to variable length data - In C#, you'd typically handle this differently, perhaps by allocating a larger buffer or using a separate mechanism for variable-length data.
}

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct PVR_SeriesData
{
    public ushort numbgrToKeep; // Episodes to k
    public byte seriesFlags;    // Record New On
    public byte dayMask;        // Days to r
    public byte matchHour;      // Added 11/22/04
    public byte matchMinute;

#if DVRHISTORY_ENABLED // You'll need to define this preprocessor directive if DVRHISTORY_ENABLED is used
    public uint ReCHistoryCause; // muthuk 18 Sep 2008 :: modified
#else
    public uint unused1;
#endif

    public uint unused2;
    public uint unused3;

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)] // Assuming MAX_PGM_NAME_LEN is 256
    public byte[] aucSeriesName; // name for the Se

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)] // Assuming MAX_PGM_DESC_LEN is 512
    public byte[] aucSeriesDescription; // Descripti
}

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct PVR_SyncNGoData
{
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)] // Assuming MAX_DVR_FILENAME_LEN is 256
    public string dvrFileName;

    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)] // Assuming MAX_DVR_FILENAME_LEN is 256
    public string trnsdfFileName;

    public byte transcodeType;
    public byte resolution;
    public byte audiolang;
    public byte transdStatus;
    public ushort bitRate;
    public ushort syncFlags;
    [MarshalAs(UnmanagedType.I1)]
    public bool bDVSEnabled;
    [MarshalAs(UnmanagedType.I1)]
    public bool bAdaptionEnabled;
    public ushort copyCount;
    public uint unused1;
    public uint unused2;

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)] // Assuming MAX_PGM_NAME_LEN is 256
    public byte[] aucProgName; // TBD - Binayak - remove lachar unused3[MAX_TRANSFER_CLIENT][MAX_TRNSD_CLIENTID_LEN];

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2 * 32)] // Assuming MAX_TRANSFER_CLIENT is 2 and MAX_TRNSD_CLIENTID_LEN is 32
    public byte[] unused3;

    [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2 * 32)] // Assuming MAX_TRANSFER_CLIENT is 2 and MAX_TRNSD_CLIENTID_LEN is 32
    public byte[] unused4;
}

[StructLayout(LayoutKind.Sequential)]
public struct PVR_InstanceData
{
    public long planned_RecStart;
    public uint planned_RecDuration;
    public long estDeletion;
    public double recStart;
    public double recDuration;
    public double pbPosition;
    public uint platformContentID;

#if DVRHISTORY_ENABLED // You'll need to define this preprocessor directive if DVRHISTORY_ENABLED is used
    public uint RecHistoryCause;
    public uint unused2;
#else
    public uint unused1;
    public uint unused2;
#endif

    public ushort instanceFlags;
    public ushort unused4;
    public uint fromParentID;
}
