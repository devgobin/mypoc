using System;
using System.IO;
using System.Text;
using System.Runtime.InteropServices;

public static class PvrDataExtractor
{
    private static readonly string cd64 = "|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\]^_`abcdefghijklmnopq";

    public static string ExtractSeriesData(string base64String, int base64Length)
    {
        byte[] binaryData = CustomBase64Decode(base64String, base64Length);
        if (binaryData == null || binaryData.Length == 0)
            return string.Empty;

        using var stream = new MemoryStream(binaryData);
        using var reader = new BinaryReader(stream);

        string header = Encoding.ASCII.GetString(reader.ReadBytes(3));
        if (header != "VMS") return string.Empty;

        reader.ReadByte(); // Skip NULL terminator
        uint platformId = reader.ReadUInt32();
        uint numSeries = reader.ReadUInt32();

        StringBuilder resultBuilder = new();

        for (int i = 0; i < numSeries; i++)
        {
            long recordStart = reader.BaseStream.Position;
            PVR_DBRec rec = ReadStruct<PVR_DBRec>(reader);

            // Read union data manually based on pvrRecordType
            byte[] unionBytes = reader.ReadBytes(rec.dataLen);
            switch (rec.pvrRecordType)
            {
                case 0:
                    var instanceData = FromBytes<PVR_InstanceData>(unionBytes);
                    resultBuilder.AppendLine($"Instance: PlatformContentID = {instanceData.platformContentID}");
                    break;
                case 2:
                    var seriesData = FromBytes<PVR_SeriesData>(unionBytes);
                    string name = Encoding.ASCII.GetString(seriesData.aucSeriesName).TrimEnd('\0');
                    resultBuilder.AppendLine($"Series: Name = {name}");
                    break;
                case 4:
                    var syncData = FromBytes<PVR_SyncNGoData>(unionBytes);
                    string fileName = Encoding.ASCII.GetString(syncData.dvrFileName).TrimEnd('\0');
                    resultBuilder.AppendLine($"Sync: File = {fileName}");
                    break;
                default:
                    resultBuilder.AppendLine("Unknown record type");
                    break;
            }
        }

        return resultBuilder.ToString();
    }

    public static byte[] CustomBase64Decode(string input, int length)
    {
        byte[] outData = new byte[length];
        int outIndex = 0, k = 0;
        byte[] inBlock = new byte[4];
        byte[] outBlock = new byte[3];

        while (k < length)
        {
            int i, len = 0;
            for (i = 0; i < 4 && k < length;)
            {
                char ch = input[k++];
                if (ch < 43 || ch > 122) continue;
                byte v = (byte)cd64[ch - 43];
                if (v == '$') continue;
                v = (byte)(v - 61);
                inBlock[i++] = (byte)(v - 1);
                len++;
            }

            if (len > 0)
            {
                DecodeBlock(inBlock, outBlock);
                for (i = 0; i < len - 1; i++)
                    outData[outIndex++] = outBlock[i];
            }
        }

        Array.Resize(ref outData, outIndex);
        return outData;
    }

    private static void DecodeBlock(byte[] input, byte[] output)
    {
        output[0] = (byte)((input[0] << 2) | (input[1] >> 4));
        output[1] = (byte)((input[1] << 4) | (input[2] >> 2));
        output[2] = (byte)(((input[2] << 6) & 0xc0) | input[3]);
    }

    private static T ReadStruct<T>(BinaryReader reader) where T : struct
    {
        byte[] bytes = reader.ReadBytes(Marshal.SizeOf<T>());
        return FromBytes<T>(bytes);
    }

    private static T FromBytes<T>(byte[] bytes) where T : struct
    {
        GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
        try
        {
            return Marshal.PtrToStructure<T>(handle.AddrOfPinnedObject());
        }
        finally
        {
            handle.Free();
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct PVR_DBRec
    {
        public uint pvr_id, programID, ui32SeriesID, quideStartSeconds, scheduleTime;
        public ushort dataLen;
        public ushort title, shortDescription, filenameRoot, moreInfo, serviceID, dispChannel, quideRunningTime;
        public ushort qualifiers, callLetters, pvrFlags;
        public byte category, eventFlags, showtimeFlags, ratingByte;
        public byte contentAdvisory, pvrRecordType, earlyMinutes, lateMinutes, recordQuality;
        public fixed byte ClientID[18];
        public fixed byte eventClientId[18];
        public uint unusedS, unused6;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct PVR_SeriesData
    {
        public ushort numbgrToKeep;
        public byte seriesFlags, dayMask, matchHour, matchMinute;
        public uint ReCHistoryCause, unused2, unused3;
        public fixed byte aucSeriesName[100];
        public fixed byte aucSeriesDescription[256];
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public unsafe struct PVR_SyncNGoData
    {
        public fixed byte dvrFileName[36];
        public fixed byte trnsdfFileName[36];
        public byte transcodeType, resolution, audiolang, transdStatus;
        public ushort bitRate, syncFlags;
        [MarshalAs(UnmanagedType.I1)] public bool bDVSEnabled;
        [MarshalAs(UnmanagedType.I1)] public bool bAdaptionEnabled;
        public ushort copyCount;
        public uint unused1, unused2;
        public fixed byte aucProgName[100];
        public fixed byte unused3[1 * 64];
        public fixed byte unused4[1 * 64];
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct PVR_InstanceData
    {
        public uint planned_RecStart, planned_RecDuration;
        public uint estDeletion;
        public double recStart, recDuration, pbPosition;
        public uint platformContentID, RecHistoryCause, unused2;
        public ushort instanceFlags, unused4;
        public uint fromParentID;
    }
}
