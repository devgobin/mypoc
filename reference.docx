using System;
using System.Collections.Generic;
using System.Text;

public class DVRDecoder
{
    // Define PVR_DBRec structure in C#
    public struct PVR_DBRec
    {
        public uint pvr_id;            // Unique PVR_ID (based on counter)
        public uint programID;         // System-wide unique identifier for this programID
        public uint ui32SeriesID;      // Mercury Series ID
        public long quideStartSeconds; // Starting time in seconds since 1970 - copied from IPG
        public long scheduleTime;      // Time recording was scheduled
        public PVR_InstanceData pvrData; // PVR_InstanceData or PVR_SeriesData or PVR_SyncNGoData (union in C++)
        public ushort dataLen;         // Length of VarData
        public ushort title;           // Name of the program. (offset into vardata)
        public ushort shortDescription; // Plot summary, etc. (offset into vardata)
        public ushort filenameRoot;    // Filename Root (offset into vardata)
        public ushort moreInfo;        // Offset into vardata
        public ushort serviceID;       // BBA service ID representing channel that the event is on
        public ushort dispChannel;     // DispChannel
        public ushort quideRunningTime; // Time in minutes from IPG data
        public ushort qualifiers;       // Showtime qualifiers
        public ushort callLetters;     // Service Call Letters (offset into vardata)
        public ushort pvrFlags;        // PVR flags
        public byte category;          // Category/genre of the program
        public byte eventFlags;        // Event flags
        public byte showtimeFlags1;    // Showtime flags
        public byte mpaaRating;        // MPAA Rating (bitfield)
        public byte svldRating;        // SVLD Rating (bitfield)
        public byte contentAdvisory;   // Content advisory flags
        public byte pvrRecordType;     // PVR Record Type
        public byte earlyMinutes;      // Minutes to start early (preferred)
        public byte lateMinutes;       // Minutes to end late (preferred)
        public byte recordQuality;     // Record Quality (unused)
        public string ClientID;        // Client ID
        public string eventClientId;   // Event Client ID
        public uint unusedS;           // Unused field
        public uint unused6;           // Unused field
        public string vardata;         // Pointer to variable length data
    }

    // Define the PVR_InstanceData structure in C#
    public struct PVR_InstanceData
    {
        public long planned_RecStart;  // Planned record start time
        public uint planned_RecDuration; // Planned record duration
        public long estDeletion;       // Estimated deletion time
        public HIRES_Time recStart;    // Actual record start time
        public HIRES_Time recDuration; // Actual record duration
        public HIRES_Time pbPosition;  // Playback position
        public uint platformContentID; // Platform content ID
        public uint RecHistoryCause;   // Record history cause
        public uint unused2;           // Unused field
        public ushort instanceFlags;   // Instance flags
        public ushort unused4;         // Unused field
        public uint fromParentID;      // From parent ID
    }

    // Define the HIRES_Time structure in C#
    public struct HIRES_Time
    {
        public uint Seconds;           // Seconds field
        public uint Milliseconds;      // Milliseconds field
    }

    // The following fields represent the union types (PVR_SeriesData, PVR_SyncNGoData)
    public struct PVR_SeriesData
    {
        public ushort numbgrToKeep;    // Episodes to keep
        public byte seriesFlags;       // Record new on/off
        public byte dayMask;           // Days to record
        public byte matchHour;         // Match hour for recording
        public byte matchMinute;       // Match minute for recording
        public uint unused1;           // Unused field
        public uint unused2;           // Unused field
        public uint unused3;           // Unused field
        public string aucSeriesName;   // Series name
        public string aucSeriesDescription; // Series description
    }

    public struct PVR_SyncNGoData
    {
        public string dvrFileName;     // DVR file name
        public string trnsdfFileName;  // Transcoded file name
        public byte transcodeType;     // Transcode type
        public byte resolution;        // Resolution
        public byte audiolang;         // Audio language
        public byte transdStatus;      // Transcode status
        public ushort bitRate;         // Bit rate
        public ushort syncFlags;       // Sync flags
        public bool bDVSEnabled;       // DVSE enabled flag
        public bool bAdaptionEnabled;  // Adaption enabled flag
        public ushort copyCount;       // Copy count
        public uint unused1;           // Unused field
        public uint unused2;           // Unused field
        public string aucProgName;     // Program name
    }

    // Base64 decoding helper methods
    private static int GetDataLength(int codeLength)
    {
        return codeLength - codeLength / 4;
    }

    private static void DecodeBlock(byte[] input, byte[] output)
    {
        output[0] = (byte)(input[0] << 2 | input[1] >> 4);
        output[1] = (byte)(input[1] << 4 | input[2] >> 2);
        output[2] = (byte)((input[2] << 6) | input[3]);
    }

    private static int Base64Decode(string inputCode, int codeLength, ref byte[] outputData)
    {
        byte[] input = new byte[4], output = new byte[3];
        int i = 0, len = 0, j = 0, k = 0;

        int outputLength = GetDataLength(codeLength);
        outputData = new byte[outputLength + 1];
        j = 0;

        while (k < codeLength)
        {
            for (len = 0; i < 4 && k < codeLength; i++)
            {
                byte v = 0;
                while (k < codeLength && v == 0)
                {
                    v = (byte)inputCode[k++];
                    v = (byte)((v < 43 || v > 122) ? 0 : cd64[v - 43]);
                    if (v != 0) v = (byte)((v == '$') ? 0 : v - 61);
                }

                if (k < codeLength)
                {
                    len++;
                    if (v != 0)
                    {
                        input[i] = (byte)(v - 1);
                    }
                    else
                    {
                        input[i] = 0;
                    }
                }
            }

            if (len > 0)
            {
                DecodeBlock(input, output);
                for (i = 0; i < len - 1; i++)
                {
                    outputData[j++] = output[i];
                }
            }
        }

        return j;
    }

    // Process the encoded string and validate header, structure, and data
    public static List<PVR_DBRec> ProcessSrsExportRequest(string encodedData)
    {
        byte[] decodedData = null;
        int decodedLength = Base64Decode(encodedData, encodedData.Length, ref decodedData);

        // Perform Header Validation
        if (decodedLength < 12)
        {
            throw new Exception("Invalid encoded data (header too short).");
        }

        // List to store decoded records
        List<PVR_DBRec> records = new List<PVR_DBRec>();
        int index = 0;

        while (index < decodedLength)
        {
            if (decodedLength - index < 200)
            {
                break;
            }

            PVR_DBRec rec = new PVR_DBRec();

            // Read PVR_DBRec fields from byte array
            rec.pvr_id = BitConverter.ToUInt32(decodedData, index);
            rec.programID = BitConverter.ToUInt32(decodedData, index + 4);
            rec.ui32SeriesID = BitConverter.ToUInt32(decodedData, index + 8);
            rec.quideStartSeconds = BitConverter.ToInt64(decodedData, index + 12);
            rec.scheduleTime = BitConverter.ToInt64(decodedData, index + 20);

            // Handle union fields (PVR_InstanceData, PVR_SeriesData, PVR_SyncNGoData)
            // Choose which union data to parse based on context (e.g., instanceData, seriesData, etc.)
            rec.pvrData = new PVR_InstanceData
            {
                planned_RecStart = BitConverter.ToInt64(decodedData, index + 28),
                planned_RecDuration = BitConverter.ToUInt32(decodedData, index + 36),
                estDeletion = BitConverter.ToInt64(decodedData, index + 40),
                recStart = new HIRES_Time
                {
                    Seconds = BitConverter.ToUInt32(decodedData, index + 48),
                    Milliseconds = BitConverter.ToUInt32(decodedData, index + 52)
                },
                recDuration = new HIRES_Time
                {
                    Seconds = BitConverter.ToUInt32(decodedData, index + 56),
                    Milliseconds = BitConverter.ToUInt32(decodedData, index + 60)
                },
                pbPosition = new HIRES_Time
                {
                    Seconds = BitConverter.ToUInt32(decodedData, index + 64),
                    Milliseconds = BitConverter.ToUInt32(decodedData, index + 68)
                },
                platformContentID = BitConverter.ToUInt32(decodedData, index + 72),
                RecHistoryCause = BitConverter.ToUInt32(decodedData, index + 76),
                unused2 = BitConverter.ToUInt32(decodedData, index + 80),
                instanceFlags = BitConverter.ToUInt16(decodedData, index + 84),
                unused4 = BitConverter.ToUInt16(decodedData, index + 86),
                fromParentID = BitConverter.ToUInt32(decodedData, index + 88)
            };

            // Read additional fields (dataLen, title, shortDescription, etc.)
            rec.dataLen = BitConverter.ToUInt16(decodedData, index + 92);
            rec.title = BitConverter.ToUInt16(decodedData, index + 94);
            rec.shortDescription = BitConverter.ToUInt16(decodedData, index + 96);
            rec.filenameRoot = BitConverter.ToUInt16(decodedData, index + 98);
            rec.moreInfo = BitConverter.ToUInt16(decodedData, index + 100);
            rec.serviceID = BitConverter.ToUInt16(decodedData, index + 102);
            rec.dispChannel = BitConverter.ToUInt16(decodedData, index + 104);
            rec.quideRunningTime = BitConverter.ToUInt16(decodedData, index + 106);
            rec.qualifiers = BitConverter.ToUInt16(decodedData, index + 108);
            rec.callLetters = BitConverter.ToUInt16(decodedData, index + 110);
            rec.pvrFlags = BitConverter.ToUInt16(decodedData, index + 112);
            rec.category = decodedData[index + 114];
            rec.eventFlags = decodedData[index + 115];
            rec.showtimeFlags1 = decodedData[index + 116];
            rec.mpaaRating = decodedData[index + 117];
            rec.svldRating = decodedData[index + 118];
            rec.contentAdvisory = decodedData[index + 119];
            rec.pvrRecordType = decodedData[index + 120];
            rec.earlyMinutes = decodedData[index + 121];
            rec.lateMinutes = decodedData[index + 122];
            rec.recordQuality = decodedData[index + 123];
            rec.ClientID = Encoding.ASCII.GetString(decodedData, index + 124, 32).Trim('\0');
            rec.eventClientId = Encoding.ASCII.GetString(decodedData, index + 156, 32).Trim('\0');
            rec.unusedS = BitConverter.ToUInt32(decodedData, index + 188);
            rec.unused6 = BitConverter.ToUInt32(decodedData, index + 192);

            // Assuming vardata starts after unused fields
            rec.vardata = Encoding.ASCII.GetString(decodedData, index + 196, rec.dataLen - 4);

            // Add record to list
            records.Add(rec);
            index += 200; // Move index by record size
        }

        return records;
    }
}

// Example Usage:
class Program
{
    static void Main(string[] args)
    {
        string encodedData = "<Your Base64 Encoded Data Here>";
        List<DVRDecoder.PVR_DBRec> records = DVRDecoder.ProcessSrsExportRequest(encodedData);

        foreach (var record in records)
        {
            Console.WriteLine($"PVR_ID: {record.pvr_id}, ProgramID: {record.programID}, SeriesID: {record.ui32SeriesID}");
        }
    }
}
